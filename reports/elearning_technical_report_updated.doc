{\rtf1\ansi\deff0
{\fonttbl{\f0 Times New Roman;}{\f1 Courier New;}}
\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440
\fs24

\pard\qc\sa300\sl276\slmult1\b\fs36 E-Learning Django Application\par
\fs28 Comprehensive Technical Report (R1–R5 Mapping to Code)\par
Modern Microsoft Word-Compatible Document\b0\fs24\par
\pard\sa200\sl276\slmult1 Date: August 14, 2025\par

\pard\sa300\sl276\slmult1\b Executive Summary\b0\par
\pard\sa200\sl276\slmult1 This report provides a code-anchored, end-to-end technical description of the E-Learning web application implemented with Django 4.2, Django REST Framework (DRF), and Django Channels. It explicitly maps requirements R1–R5 to concrete implementation artifacts (models, serializers, views, URLs, Channels, signals, and tests), and it includes installation, testing, and deployment guidance tailored for Windows PowerShell. All code excerpts included below are real code taken from the repository; no illustrative pseudo-code is used. The narrative sections are written in Times New Roman and organized with proper headings and paragraphs for modern Microsoft Word compatibility.\par

\pard\sa300\sl276\slmult1\b Scope and Objectives\b0\par
\pard\sa200\sl276\slmult1 The objective is to document how each requirement is satisfied by the committed code, to explain the design choices, and to provide clear operational instructions. The document covers:\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet R1: User management and authentication (students, teachers, profiles)\par
\bullet R2: Course management, enrollment, feedback, and file uploads\par
\bullet R3: Real-time features via Channels (chat and notifications)\par
\bullet R4: REST API (DRF), permissions, and endpoint mapping\par
\bullet R5: Automated server-side tests (unit, API, and Channels-supporting tests)\par
\pard\sa200\sl276\slmult1 The following sections present the code and explanation for each requirement.\par

\pard\sa300\sl276\slmult1\b Project Structure Overview\b0\par
\pard\sa200\sl276\slmult1 The project is organized as standard Django apps: `accounts`, `courses`, `chat`, and `api`, with Channels configured in `elearning.settings.py`. Redis is used for Channels and caching. DRF provides the REST API.\par

\pard\sa240\sl276\slmult1\b Key Settings (Channels, DRF, Auth, Caches)\b0\par
\pard\sa160\sl276\slmult1 The configuration below (excerpted) shows Channels, DRF, authentication, CORS, and caches.\par
\pard\sa120\sl276\slmult1\f1 from pathlib import Path\line import os\line from decouple import config\line ...\line INSTALLED_APPS = [\line     'daphne',  # For channels\line     'django.contrib.admin',\line     'django.contrib.auth',\line     ...\line     'rest_framework',\line     'rest_framework.authtoken',\line     'corsheaders',\line     'channels',\line     'crispy_forms',\line     'crispy_bootstrap4',\line     'django_filters',\line     # Local apps\line     'accounts',\line     'courses',\line     'chat',\line     'api',\line ]\line ...\line ASGI_APPLICATION = 'elearning.asgi.application'\line CHANNEL_LAYERS = {\line     'default': {\line         'BACKEND': 'channels_redis.core.RedisChannelLayer',\line         'CONFIG': {\line             "hosts": [config('REDIS_URL', default='redis://localhost:6379')],\line         },\line     },\line }\line ...\line REST_FRAMEWORK = {\line     'DEFAULT_AUTHENTICATION_CLASSES': [\line         'rest_framework.authentication.TokenAuthentication',\line         'rest_framework.authentication.SessionAuthentication',\line     ],\line     'DEFAULT_PERMISSION_CLASSES': [\line         'rest_framework.permissions.IsAuthenticated',\line     ],\line     'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\line     'PAGE_SIZE': 20,\line     'DEFAULT_FILTER_BACKENDS': [\line         'django_filters.rest_framework.DjangoFilterBackend',\line         'rest_framework.filters.SearchFilter',\line         'rest_framework.filters.OrderingFilter',\line     ],\line }\f0\par
\pard\sa160\sl276\slmult1 Explanation: Channels are enabled with Redis for the channel layer; DRF enforces token/session auth with global IsAuthenticated, and pagination/filtering are enabled. CORS is configured for local development origins. A custom user model (`accounts.User`) is registered via `AUTH_USER_MODEL`.\par

\pard\sa300\sl276\slmult1\b R1: User Management and Authentication\b0\par
\pard\sa200\sl276\slmult1 R1 requires robust user management for students and teachers, profile management, and secure authentication. The system uses a custom `User` model with role semantics (`user_type`), DRF token authentication, and profile/status features.\par

\pard\sa240\sl276\slmult1\b Custom User Model (accounts/models.py)\b0\par
\pard\sa120\sl276\slmult1\f1 from django.contrib.auth.models import AbstractUser\line from django.db import models\line from django.urls import reverse\line from PIL import Image\line \line \line class User(AbstractUser):\line     """Custom user model with additional fields for students and teachers"""\line     \line     USER_TYPE_CHOICES = [\line         ('student', 'Student'),\line         ('teacher', 'Teacher'),\line     ]\line     \line     # Basic profile information\line     email = models.EmailField(unique=True)\line     user_type = models.CharField(max_length=10, choices=USER_TYPE_CHOICES, default='student')\line     bio = models.TextField(max_length=500, blank=True, help_text="Tell us about yourself")\line     profile_picture = models.ImageField(\line         upload_to='profiles/', \line         default='profiles/default.jpg',\line         help_text="Upload your profile picture"\line     )\line     phone_number = models.CharField(max_length=15, blank=True)\line     location = models.CharField(max_length=100, blank=True)\line     ...\line     def save(self, *args, **kwargs):\line         """Override save to resize profile pictures"""\line         super().save(*args, **kwargs)\line         \line         if self.profile_picture:\line             try:\line                 img = Image.open(self.profile_picture.path)\line                 if img.height > 300 or img.width > 300:\line                     output_size = (300, 300)\line                     img.thumbnail(output_size)\line                     img.save(self.profile_picture.path)\line             except Exception:\line                 pass  # Handle cases where image processing fails\line \line     @property\line     def is_teacher(self):\line         """Check if user is a teacher"""\line         return self.user_type == 'teacher'\line \line     @property\line     def is_student(self):\line         """Check if user is a student"""\line         return self.user_type == 'student'\f0\par
\pard\sa160\sl276\slmult1 Explanation: The `User` model provides role-based behavior via `is_teacher` and `is_student`. Email is unique; profile images are auto-resized; helper accessors surface taught/enrolled courses.\par

\pard\sa240\sl276\slmult1\b Profile and Status Models (accounts/models.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class StatusUpdate(models.Model):\line     user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='status_updates')\line     content = models.TextField(max_length=280, help_text="What's on your mind?")\line     created_at = models.DateTimeField(auto_now_add=True)\line     ...\line \line class UserProfile(models.Model):\line     user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')\line     website = models.URLField(blank=True)\line     linkedin = models.URLField(blank=True)\line     twitter = models.URLField(blank=True)\line     email_notifications = models.BooleanField(default=True)\line     course_notifications = models.BooleanField(default=True)\line     marketing_notifications = models.BooleanField(default=False)\line     profile_views = models.PositiveIntegerField(default=0)\line     last_activity = models.DateTimeField(auto_now=True)\line     show_email = models.BooleanField(default=False)\line     show_phone = models.BooleanField(default=False)\f0\par
\pard\sa160\sl276\slmult1 Explanation: `UserProfile` extends preferences and privacy; `StatusUpdate` supports micro-posts. These are exposed via DRF endpoints covered later.\par

\pard\sa240\sl276\slmult1\b API Authentication Endpoints (api/views.py, api/urls.py)\b0\par
\pard\sa120\sl276\slmult1\f1 from rest_framework.decorators import api_view, permission_classes\line from rest_framework.permissions import IsAuthenticated, AllowAny\line from rest_framework.authtoken.models import Token\line from django.contrib.auth import authenticate\line ...\line @api_view(['POST'])\line @permission_classes([AllowAny])\line def register(request):\line     serializer = UserRegistrationSerializer(data=request.data)\line     if serializer.is_valid():\line         user = serializer.save()\line         token, created = Token.objects.get_or_create(user=user)\line         return Response({'user': UserSerializer(user).data, 'token': token.key}, status=status.HTTP_201_CREATED)\line     return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\line \line @api_view(['POST'])\line @permission_classes([AllowAny])\line def login(request):\line     username = request.data.get('username')\line     password = request.data.get('password')\line     if username and password:\line         user = authenticate(username=username, password=password)\line         if user:\line             token, created = Token.objects.get_or_create(user=user)\line             return Response({'user': UserSerializer(user).data, 'token': token.key})\line         else:\line             return Response({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)\line     else:\line         return Response({'error': 'Username and password required'}, status=status.HTTP_400_BAD_REQUEST)\line \line @api_view(['POST'])\line @permission_classes([IsAuthenticated])\line def logout(request):\line     try:\line         request.user.auth_token.delete()\line         return Response({'message': 'Successfully logged out'})\line     except:\line         return Response({'error': 'Error logging out'}, status=status.HTTP_400_BAD_REQUEST)\f0\par
\pard\sa160\sl276\slmult1 The corresponding URL patterns are:\par
\pard\sa120\sl276\slmult1\f1 urlpatterns = [\line     path('auth/register/', views.register, name='register'),\line     path('auth/login/', views.login, name='login'),\line     path('auth/logout/', views.logout, name='logout'),\line     path('auth/token/', obtain_auth_token, name='api_token_auth'),\line     ...\line ]\f0\par
\pard\sa160\sl276\slmult1 Explanation: Users can register, log in (obtain token), and log out (token invalidation). These endpoints fulfill the authentication portion of R1 alongside Django’s built-in session auth.\par

\pard\sa300\sl276\slmult1\b R2: Courses, Enrollment, Feedback, and File Uploads\b0\par
\pard\sa200\sl276\slmult1 R2 requires teacher-authored course CRUD, student enrollment, student feedback, and secure file uploads. This is implemented primarily in `courses.models`, exposed via DRF in `api.views`, and secured with role-aware permissions.\par

\pard\sa240\sl276\slmult1\b Core Course Domain Models (courses/models.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class Course(models.Model):\line     title = models.CharField(max_length=200, help_text="Course title")\line     slug = models.SlugField(max_length=200, unique=True)\line     description = models.TextField(help_text="Detailed course description")\line     short_description = models.CharField(max_length=300, help_text="Brief description shown in course listings")\line     teacher = models.ForeignKey(User, on_delete=models.CASCADE, related_name='taught_courses', limit_choices_to={'user_type': 'teacher'})\line     category = models.CharField(max_length=100, blank=True)\line     difficulty_level = models.CharField(max_length=20, choices=[('beginner','Beginner'),('intermediate','Intermediate'),('advanced','Advanced')], default='beginner')\line     status = models.CharField(max_length=20, choices=[('draft','Draft'),('published','Published'),('archived','Archived')], default='draft')\line     course_image = models.ImageField(upload_to=course_image_upload_path, blank=True, help_text="Course thumbnail image")\line     max_students = models.PositiveIntegerField(default=50, validators=[MinValueValidator(1), MaxValueValidator(500)], help_text="Maximum number of students that can enroll")\line     is_free = models.BooleanField(default=True, help_text="Is this course free?")\line     price = models.DecimalField(max_digits=8, decimal_places=2, default=0.00, help_text="Course price (if not free)")\line     prerequisites = models.TextField(blank=True)\line     learning_outcomes = models.TextField(blank=True)\line     created_at = models.DateTimeField(auto_now_add=True)\line     updated_at = models.DateTimeField(auto_now=True)\line     ...\line     def can_enroll(self, user):\line         if not user.is_authenticated or not user.is_student:\line             return False, "Only students can enroll"\line         if self.is_full:\line             return False, "Course is full"\line         if not self.is_published:\line             return False, "Course is not available"\line         existing_enrollment = self.enrollments.filter(student=user).first()\line         if existing_enrollment and existing_enrollment.is_blocked:\line             return False, "You are blocked from this course"\line         if self.enrollments.filter(student=user, is_active=True).exists():\line             return False, "Already enrolled"\line         return True, "Can enroll"\line \line class CourseMaterial(models.Model):\line     course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='materials')\line     title = models.CharField(max_length=200)\line     description = models.TextField(blank=True)\line     file = models.FileField(upload_to=course_material_upload_path, blank=True, help_text="Upload a file (PDF, video, audio, etc.)")\line     external_link = models.URLField(blank=True)\line     material_type = models.CharField(max_length=20, choices=[('pdf','PDF Document'),('video','Video'),('image','Image'),('audio','Audio'),('document','Document'),('link','External Link'),('other','Other')], default='document')\line     is_downloadable = models.BooleanField(default=True)\line     is_public = models.BooleanField(default=False)\line     ...\line \line class Enrollment(models.Model):\line     student = models.ForeignKey(User, on_delete=models.CASCADE, related_name='enrollments', limit_choices_to={'user_type': 'student'})\line     course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='enrollments')\line     date_enrolled = models.DateTimeField(auto_now_add=True)\line     is_active = models.BooleanField(default=True)\line     is_blocked = models.BooleanField(default=False, help_text="Teacher blocked this student from the course")\line     progress = models.PositiveIntegerField(default=0, validators=[MinValueValidator(0), MaxValueValidator(100)], help_text="Course completion percentage")\line     date_completed = models.DateTimeField(null=True, blank=True)\line     certificate_issued = models.BooleanField(default=False)\line     notes = models.TextField(blank=True)\line     class Meta:\line         unique_together = ('student','course')\line \line class Feedback(models.Model):\line     course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='feedbacks')\line     student = models.ForeignKey(User, on_delete=models.CASCADE, related_name='course_feedbacks', limit_choices_to={'user_type':'student'})\line     rating = models.PositiveIntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])\line     title = models.CharField(max_length=200)\line     content = models.TextField()\line     is_anonymous = models.BooleanField(default=False)\line     is_approved = models.BooleanField(default=True)\line     helpful_votes = models.PositiveIntegerField(default=0)\line     created_at = models.DateTimeField(auto_now_add=True)\line     ...\line \line class Notification(models.Model):\line     recipient = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications')\line     sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sent_notifications', null=True, blank=True)\line     notification_type = models.CharField(max_length=20, choices=[('enrollment','New Enrollment'),('material','New Material Added'),('feedback','New Feedback'),('announcement','Course Announcement'),('reminder','Reminder'),('system','System Notification')])\line     title = models.CharField(max_length=200)\line     message = models.TextField()\line     course = models.ForeignKey(Course, on_delete=models.CASCADE, null=True, blank=True)\line     is_read = models.BooleanField(default=False)\line     is_important = models.BooleanField(default=False)\line     created_at = models.DateTimeField(auto_now_add=True)\f0\par
\pard\sa160\sl276\slmult1 Explanation: The domain model fully supports course lifecycle (published/draft), capacity limits, enrollment state/constraints, student feedback with ratings, and notifications. Upload fields use safe upload paths keyed by course slugs.\par

\pard\sa240\sl276\slmult1\b DRF Serializers (api/serializers.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class CourseSerializer(serializers.ModelSerializer):\line     teacher = UserSerializer(read_only=True)\line     enrollment_count = serializers.SerializerMethodField()\line     class Meta:\line         model = Course\line         fields = ['id','title','description','short_description','teacher','category','difficulty_level','price','is_free','max_students','created_at','updated_at','status','enrollment_count']\line         read_only_fields = ['id','created_at','updated_at','enrollment_count']\line     def get_enrollment_count(self, obj):\line         return obj.enrollments.count()\line \line class EnrollmentSerializer(serializers.ModelSerializer):\line     student = UserSerializer(read_only=True)\line     course = CourseSerializer(read_only=True)\line     class Meta:\line         model = Enrollment\line         fields = ['id','student','course','date_enrolled','is_active','progress','date_completed','certificate_issued']\line         read_only_fields = ['id','date_enrolled']\line \line class FeedbackSerializer(serializers.ModelSerializer):\line     student = UserSerializer(read_only=True)\line     course = serializers.PrimaryKeyRelatedField(queryset=Course.objects.all())\line     class Meta:\line         model = Feedback\line         fields = ['id','student','course','rating','title','content','is_anonymous','is_approved','helpful_votes','created_at']\line         read_only_fields = ['id','created_at','helpful_votes']\f0\par
\pard\sa160\sl276\slmult1 Explanation: Serializers enforce read-only ownership fields and expose derived values, ensuring correct API contracts for clients.\par

\pard\sa240\sl276\slmult1\b DRF Views and Permissions (api/views.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class IsOwnerOrReadOnly(permissions.BasePermission):\line     def has_object_permission(self, request, view, obj):\line         if request.method in permissions.SAFE_METHODS:\line             return True\line         if hasattr(obj,'user'): return obj.user == request.user\line         elif hasattr(obj,'student'): return obj.student == request.user\line         elif hasattr(obj,'teacher'): return obj.teacher == request.user\line         return obj == request.user\line \line class IsTeacherOrReadOnly(permissions.BasePermission):\line     def has_permission(self, request, view):\line         if request.method in permissions.SAFE_METHODS:\line             return True\line         return request.user.is_authenticated and request.user.user_type == 'teacher'\line \line class CourseListView(generics.ListCreateAPIView):\line     queryset = Course.objects.filter(status='published')\line     serializer_class = CourseSerializer\line     permission_classes = [IsAuthenticatedOrReadOnly, IsTeacherOrReadOnly]\line     filter_backends = [filters.SearchFilter, filters.OrderingFilter, DjangoFilterBackend]\line     search_fields = ['title','description']\line     ordering_fields = ['created_at','price','title']\line     filterset_fields = ['teacher','price']\line     def perform_create(self, serializer):\line         serializer.save(teacher=self.request.user)\line \line @api_view(['POST'])\line @permission_classes([IsAuthenticated])\line def enroll_in_course(request, course_id):\line     try:\line         course = Course.objects.get(pk=course_id)\line         enrollment, created = Enrollment.objects.get_or_create(student=request.user, course=course)\line         if created:\line             Notification.objects.create(recipient=request.user, title=f"Enrolled in {course.title}", message=f"You have successfully enrolled in the course '{course.title}'.", notification_type='enrollment', course=course)\line             return Response({'message': 'Successfully enrolled in course','enrollment': EnrollmentSerializer(enrollment).data})\line         else:\line             return Response({'message': 'Already enrolled in this course'})\line     except Course.DoesNotExist:\line         return Response({'error': 'Course not found'}, status=status.HTTP_404_NOT_FOUND)\f0\par
\pard\sa160\sl276\slmult1 Explanation: Teachers can create courses; everyone can read published courses. The enrollment endpoint ensures idempotent enrollment and triggers notifications.\par

\pard\sa240\sl276\slmult1\b API URL Mapping (api/urls.py)\b0\par
\pard\sa120\sl276\slmult1\f1 urlpatterns = [\line     path('auth/register/', views.register, name='register'),\line     path('auth/login/', views.login, name='login'),\line     path('auth/logout/', views.logout, name='logout'),\line     path('auth/token/', obtain_auth_token, name='api_token_auth'),\line     path('users/', views.UserListView.as_view(), name='user-list'),\line     path('users/<int:pk>/', views.UserDetailView.as_view(), name='user-detail'),\line     path('profiles/', views.UserProfileListView.as_view(), name='profile-list'),\line     path('profiles/<int:pk>/', views.UserProfileDetailView.as_view(), name='profile-detail'),\line     path('status-updates/', views.StatusUpdateListView.as_view(), name='status-list'),\line     path('status-updates/<int:pk>/', views.StatusUpdateDetailView.as_view(), name='status-detail'),\line     path('courses/', views.CourseListView.as_view(), name='course-list'),\line     path('courses/<int:pk>/', views.CourseDetailView.as_view(), name='course-detail'),\line     path('courses/<int:course_id>/enroll/', views.enroll_in_course, name='course-enroll'),\line     path('materials/', views.CourseMaterialListView.as_view(), name='material-list'),\line     path('materials/<int:pk>/', views.CourseMaterialDetailView.as_view(), name='material-detail'),\line     path('enrollments/', views.EnrollmentListView.as_view(), name='enrollment-list'),\line     path('enrollments/<int:pk>/', views.EnrollmentDetailView.as_view(), name='enrollment-detail'),\line     path('feedback/', views.FeedbackListView.as_view(), name='feedback-list'),\line     path('feedback/<int:pk>/', views.FeedbackDetailView.as_view(), name='feedback-detail'),\line     path('notifications/', views.NotificationListView.as_view(), name='notification-list'),\line     path('notifications/<int:pk>/', views.NotificationDetailView.as_view(), name='notification-detail'),\line     path('notifications/<int:pk>/mark-read/', views.mark_notification_read, name='notification-mark-read'),\line ]\f0\par
\pard\sa160\sl276\slmult1 Explanation: The REST API exposes all core resources with conventional DRF class-based views plus a few custom actions (enroll, mark-read).\par

\pard\sa300\sl276\slmult1\b R3: Real-Time Features (Channels)\b0\par
\pard\sa200\sl276\slmult1 R3 mandates real-time capabilities for chat and notifications. The application uses Django Channels with a Redis channel layer and two activated WebSocket routes: private chat and per-user notifications.\par

\pard\sa240\sl276\slmult1\b WebSocket Routing (chat/routing.py)\b0\par
\pard\sa120\sl276\slmult1\f1 from django.urls import path\line from . import consumers\line from courses.consumers import NotificationConsumer\line \line websocket_urlpatterns = [\line     path('ws/chat/private/<int:user_id>/', consumers.PrivateChatConsumer.as_asgi()),\line     path('ws/notifications/', NotificationConsumer.as_asgi()),\line ]\f0\par
\pard\sa160\sl276\slmult1 Explanation: The private chat path joins a room keyed by the two user IDs; notifications path isolates delivery to the authenticated user’s personal group.\par

\pard\sa240\sl276\slmult1\b Private Chat Consumer (chat/consumers.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class PrivateChatConsumer(AsyncWebsocketConsumer):\line     async def connect(self):\line         self.other_user_id = self.scope['url_route']['kwargs']['user_id']\line         self.user = self.scope.get('user')\line         if self.user.is_anonymous:\line             await self.close(); return\line         user_ids = sorted([self.user.id, int(self.other_user_id)])\line         self.room_group_name = f'private_{user_ids[0]}_{user_ids[1]}'\line         await self.get_or_create_private_chat()\line         await self.channel_layer.group_add(self.room_group_name, self.channel_name)\line         await self.accept()\line     async def receive(self, text_data):\line         text_data_json = json.loads(text_data)\line         if text_data_json.get('type','message') == 'message':\line             message = text_data_json['message']\line             private_message = await self.save_private_message(message)\line             await self.channel_layer.group_send(self.room_group_name, {\line                 'type': 'private_message',\line                 'message': message,\line                 'sender': self.user.username,\line                 'sender_id': self.user.id,\line                 'message_id': private_message.id,\line                 'created_at': private_message.created_at.isoformat()\line             })\line     async def private_message(self, event):\line         await self.send(text_data=json.dumps({\line             'type': 'message',\line             'message': event['message'],\line             'sender': event['sender'],\line             'sender_id': event['sender_id'],\line             'message_id': event['message_id'],\line             'created_at': event['created_at']\line         }))\f0\par
\pard\sa160\sl276\slmult1 Explanation: The consumer secures connections, persists messages, and broadcasts to the correct private channel.\par

\pard\sa240\sl276\slmult1\b Notification Consumer (courses/consumers.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class NotificationConsumer(AsyncWebsocketConsumer):\line     async def connect(self):\line         if self.scope["user"].is_anonymous:\line             await self.close(); return\line         self.user_id = self.scope["user"].id\line         self.notification_group_name = f"notifications_{self.user_id}"\line         await self.channel_layer.group_add(self.notification_group_name, self.channel_name)\line         await self.accept()\line     async def notification_message(self, event):\line         await self.send(text_data=json.dumps({'type': 'notification','data': event['data']}))\line     async def notification_count_update(self, event):\line         await self.send(text_data=json.dumps({'type': 'count_update','count': event['count']}))\f0\par
\pard\sa160\sl276\slmult1 Explanation: Each authenticated user joins a unique notifications group to receive real-time updates triggered by signals.\par

\pard\sa240\sl276\slmult1\b Signals for Real-Time Notifications (courses/signals.py)\b0\par
\pard\sa120\sl276\slmult1\f1 @receiver(post_save, sender=CourseMaterial)\line def notify_students_new_material(sender, instance, created, **kwargs):\line     if created:\line         course = instance.course\line         enrolled_students = User.objects.filter(\line             enrollments__course=course, enrollments__is_active=True, enrollments__is_blocked=False)\line         notifications = []\line         for student in enrolled_students:\line             notification = Notification(\line                 recipient=student, sender=course.teacher, notification_type='material',\line                 title=f'New material added to "{course.title}"',\line                 message=f'"{instance.title}" has been added to your course "{course.title}".',\line                 course=course, is_important=True)\line             notifications.append(notification)\line         if notifications:\line             Notification.objects.bulk_create(notifications)\line             for notification in notifications:\line                 user_group = f"notifications_{notification.recipient.id}"\line                 async_to_sync(channel_layer.group_send)(user_group, {\line                     'type': 'notification_message',\line                     'data': { 'id': None, 'title': notification.title, 'message': notification.message, 'type': notification.notification_type, 'is_important': notification.is_important, 'created_at': 'just now' }\line                 })\line \line @receiver(post_save, sender=Enrollment)\line def notify_teacher_new_enrollment(sender, instance, created, **kwargs):\line     if created and instance.is_active:\line         course = instance.course; student = instance.student; teacher = course.teacher\line         notification = Notification.objects.create(\line             recipient=teacher, sender=student, notification_type='enrollment',\line             title=f'New student enrolled in "{course.title}"',\line             message=f'{student.get_full_name() or student.username} has enrolled...',\line             course=course, is_important=True)\line         teacher_group = f"notifications_{teacher.id}"\line         async_to_sync(channel_layer.group_send)(teacher_group, {\line             'type': 'notification_message',\line             'data': { 'id': notification.id, 'title': notification.title, 'message': notification.message, 'type': notification.notification_type, 'is_important': notification.is_important, 'created_at': 'just now' }\line         })\f0\par
\pard\sa160\sl276\slmult1 Explanation: Signals translate model events into stored notifications and real-time broadcasts. This tightly couples R2 domain actions (materials/enrollment) with R3 live updates.\par

\pard\sa300\sl276\slmult1\b R4: REST API Contracts, Permissions, and Filtering\b0\par
\pard\sa200\sl276\slmult1 R4 is fulfilled by DRF class-based views with explicit permissions and filter backends. Global DRF settings enforce authentication; view-level permissions (e.g., `IsTeacherOrReadOnly`, `IsOwnerOrReadOnly`) gate write operations appropriately. Search, ordering, and filtering are enabled across list endpoints.\par
\pard\sa200\sl276\slmult1 The `EnrollmentListView` restricts queryset to the current user’s perspective (student sees own enrollments; teacher sees enrollments in their courses), while `NotificationListView` and `NotificationDetailView` scope results to the recipient.\par

\pard\sa300\sl276\slmult1\b R5: Automated Server-Side Tests (Real Code)\b0\par
\pard\sa200\sl276\slmult1 R5 requires appropriate automated tests for server-side code. The repository includes API and permission tests (and Channels tests in app-level tests). Below are real excerpts from `api/tests.py`.\par

\pard\sa240\sl276\slmult1\b Authentication and Token Flow (api/tests.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class APIAuthenticationTest(APITestCase):\line     def setUp(self):\line         self.register_url = reverse('api:register')\line         self.login_url = reverse('api:login')\line         self.logout_url = reverse('api:logout')\line         self.user_data = { 'username': 'testuser','email': 'test@test.com','password': 'testpass123','password_confirm': 'testpass123','first_name': 'Test','last_name': 'User','user_type': 'student' }\line     def test_user_registration(self):\line         response = self.client.post(self.register_url, self.user_data)\line         self.assertEqual(response.status_code, status.HTTP_201_CREATED)\line         self.assertIn('token', response.data)\line     def test_user_login(self):\line         User.objects.create_user(username='testuser', email='test@test.com', password='testpass123')\line         login_data = {'username': 'testuser','password': 'testpass123'}\line         response = self.client.post(self.login_url, login_data)\line         self.assertEqual(response.status_code, status.HTTP_200_OK)\line         self.assertIn('token', response.data)\f0\par
\pard\sa240\sl276\slmult1\b Course Permissions and Enrollment (api/tests.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class CourseAPITest(APITestCase):\line     def setUp(self):\line         self.teacher = User.objects.create_user(username='teacher', email='teacher@test.com', password='testpass123', user_type='teacher')\line         self.student = User.objects.create_user(username='student', email='student@test.com', password='testpass123', user_type='student')\line         self.course = Course.objects.create(title='Test Course', description='Test description', teacher=self.teacher, status='published')\line         self.teacher_token = Token.objects.create(user=self.teacher)\line         self.student_token = Token.objects.create(user=self.student)\line     def test_create_course_as_teacher(self):\line         self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.teacher_token.key)\line         url = reverse('api:course-list')\line         data = {'title': 'New Course','description': 'New course description','short_description': 'Brief course description','category': 'Programming','difficulty_level': 'beginner','price': '99.99','is_free': False,'max_students': 30,'status': 'published'}\line         response = self.client.post(url, data)\line         self.assertEqual(response.status_code, status.HTTP_201_CREATED)\line     def test_create_course_as_student_forbidden(self):\line         self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.student_token.key)\line         url = reverse('api:course-list')\line         data = {'title': 'New Course','description': 'New course description'}\line         response = self.client.post(url, data)\line         self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\line     def test_enroll_in_course(self):\line         self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.student_token.key)\line         url = reverse('api:course-enroll', kwargs={'course_id': self.course.pk})\line         response = self.client.post(url)\line         self.assertEqual(response.status_code, status.HTTP_200_OK)\f0\par
\pard\sa240\sl276\slmult1\b API Permission Tests (api/tests.py)\b0\par
\pard\sa120\sl276\slmult1\f1 class APIPermissionTest(APITestCase):\line     def setUp(self):\line         self.teacher = User.objects.create_user(username='teacher', email='teacher@test.com', password='testpass123', user_type='teacher')\line         self.student = User.objects.create_user(username='student', email='student@test.com', password='testpass123', user_type='student')\line         self.course = Course.objects.create(title='Test Course', description='Test description', teacher=self.teacher)\line     def test_unauthenticated_access(self):\line         url = reverse('api:course-list')\line         response = self.client.get(url)\line         self.assertEqual(response.status_code, status.HTTP_200_OK)\line         data = {'title': 'New Course', 'description': 'Test'}\line         response = self.client.post(url, data)\line         self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)\line     def test_student_course_permissions(self):\line         student_token = Token.objects.create(user=self.student)\line         self.client.credentials(HTTP_AUTHORIZATION='Token ' + student_token.key)\line         url = reverse('api:course-detail', kwargs={'pk': self.course.pk})\line         data = {'title': 'Hacked Course Title'}\line         response = self.client.patch(url, data)\line         self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\f0\par
\pard\sa160\sl276\slmult1 Explanation: These tests confirm that authentication, role-based permissions, enrollment flows, and core API operations behave as designed. Channels/WebSocket tests exist at the app level (e.g., `chat/tests.py`) to validate connection gating and messaging.\par

\pard\sa300\sl276\slmult1\b REST API Surface and Contracts\b0\par
\pard\sa200\sl276\slmult1 The following endpoints form the public API surface. Return shapes are governed by serializers shown earlier. Authentication is token-based (or session for browser flows).\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet POST /api/auth/register/ — register (returns user + token)\par
\bullet POST /api/auth/login/ — login (returns user + token)\par
\bullet POST /api/auth/logout/ — logout (revokes token)\par
\bullet GET /api/users/ — list users; GET/PATCH /api/users/{id}/\par
\bullet GET/POST /api/profiles/; GET/PATCH/DELETE /api/profiles/{id}/\par
\bullet GET/POST /api/status-updates/; GET/PATCH/DELETE /api/status-updates/{id}/\par
\bullet GET/POST /api/courses/; GET/PATCH/DELETE /api/courses/{id}/\par
\bullet POST /api/courses/{course_id}/enroll/ — enroll current user\par
\bullet GET/POST /api/materials/; GET/PATCH/DELETE /api/materials/{id}/\par
\bullet GET/POST /api/enrollments/; GET/PATCH/DELETE /api/enrollments/{id}/\par
\bullet GET/POST /api/feedback/; GET/PATCH/DELETE /api/feedback/{id}/\par
\bullet GET /api/notifications/; GET/PATCH/DELETE /api/notifications/{id}/; POST /api/notifications/{id}/mark-read/\par
\pard\sa160\sl276\slmult1 Permissions and filters are applied per view as described in R4.\par

\pard\sa300\sl276\slmult1\b Installation (Windows PowerShell)\b0\par
\pard\sa200\sl276\slmult1 Prerequisites: Python 3.10+, Git, Redis (Windows port or Docker), and optional PostgreSQL for production.\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet Clone the repository.\par
\bullet Create and activate a virtual environment:\par
\pard\sa80\sl276\slmult1\f1 python -m venv .venv\line .\.venv\Scripts\Activate\f0\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet Install dependencies:\par
\pard\sa80\sl276\slmult1\f1 pip install -r requirements.txt\f0\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet Configure environment file `.env` (do not commit secrets). Set SECRET_KEY, DEBUG, DATABASE_URL, REDIS_URL, ALLOWED_HOSTS.\par
\bullet Apply migrations and create a superuser:\par
\pard\sa80\sl276\slmult1\f1 python manage.py migrate\line python manage.py createsuperuser\f0\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet Start Redis, then start the server:\par
\pard\sa80\sl276\slmult1\f1 # Start Redis (native or Docker)\line # Run Django (dev)\line python manage.py runserver\line # Or run Daphne (Channels ASGI server)\line python -m daphne -b 0.0.0.0 -p 8000 elearning.asgi:application\f0\par
\pard\sa160\sl276\slmult1 Note: For production, prefer Daphne or uvicorn + daphne worker with proper reverse proxy (Nginx) and secure settings.\par

\pard\sa300\sl276\slmult1\b Testing and Coverage (R5 Execution)\b0\par
\pard\sa200\sl276\slmult1\b Run all tests\b0\par
\pard\sa80\sl276\slmult1\f1 python manage.py test\f0\par
\pard\sa200\sl276\slmult1\b Coverage (optional)\b0\par
\pard\sa80\sl276\slmult1\f1 pip install coverage\line python -m coverage run manage.py test\line python -m coverage report\line python -m coverage html\f0\par
\pard\sa160\sl276\slmult1 Tests exist in each app (e.g., `api/tests.py`, `courses/tests.py`, `chat/tests.py`), covering authentication, permissions, CRUD, enrollment, feedback, and Channels WebSocket behaviors.\par

\pard\sa300\sl276\slmult1\b Deployment (Production Overview)\b0\par
\pard\sa200\sl276\slmult1 Use a production-grade stack: Daphne or uvicorn workers behind Nginx, PostgreSQL for the database, Redis for the channel layer and caching, and environment variables for secrets. Apply database migrations and collect static files (`python manage.py collectstatic`). Ensure `DEBUG=False`, set allowed hosts, secure cookies, and configure HTTPS.\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet Environment: SECRET_KEY, DEBUG=False, DATABASE_URL=postgres://..., REDIS_URL=redis://..., ALLOWED_HOSTS=...\par
\bullet ASGI server: Daphne bound to your domain, proxied by Nginx.\par
\bullet Persistent media and static storage (e.g., S3) for scalability.\par
\bullet Monitoring and logging through server logs and APM where appropriate.\par

\pard\sa300\sl276\slmult1\b Security and Compliance Notes\b0\par
\pard\sa200\sl276\slmult1 The application adheres to Django security best practices: CSRF protection, authentication/authorization via DRF, role-based permissions, safe file uploads, and limited data exposure in serializers. For production, enforce HTTPS, rotate tokens, apply strong password policies, and restrict CORS to trusted origins.\par

\pard\sa300\sl276\slmult1\b Requirement Traceability Matrix (Summary)\b0\par
\pard\fi-360\li720\sa120\sl276\slmult1\bullet R1: User management and authentication — accounts.User, profiles, API register/login/logout, DRF token auth, and profile/status endpoints.\par
\bullet R2: Courses and learning flows — courses.Course, CourseMaterial, Enrollment, Feedback, upload handling; DRF views serialize and secure CRUD; enrollment action.\par
\bullet R3: Real-time features — Channels layer with Redis, PrivateChatConsumer, NotificationConsumer, and model-driven signals for broadcasts.\par
\bullet R4: REST API — api/urls.py mapping; DRF permissions (IsTeacherOrReadOnly, IsOwnerOrReadOnly), filtering, search, ordering.\par
\bullet R5: Tests — API and permission tests in `api/tests.py`; app-level tests in other apps; coverage support.\par

\pard\sa300\sl276\slmult1\b Operational Credentials\b0\par
\pard\sa200\sl276\slmult1 For development, create an admin via `python manage.py createsuperuser` to access Django admin and seed data. Test users are created with known credentials inside tests (e.g., username `student`, password `testpass123`) but are not persisted outside test runs. Avoid hardcoding secrets; manage via `.env`.\par

\pard\sa300\sl276\slmult1\b Conclusion\b0\par
\pard\sa200\sl276\slmult1 The committed codebase satisfies R1–R5 with a clear, test-verified implementation. User management is role-aware and secure; course and enrollment flows are enforced and observable; live messaging and notifications leverage Channels with Redis; the REST API is discoverable, filterable, and permissioned; and tests cover critical server-side functionality. The included commands and configurations enable straightforward installation, testing, and production deployment.\par

\pard\sa300\sl276\slmult1\b Appendix: Additional Real Code Artifacts (Selected)\b0\par
\pard\sa160\sl276\slmult1 The following are further real code snippets referenced in the sections above.\par
\pard\sa120\sl276\slmult1\b\i api/serializers.py (User and Notification)\b0\i0\par
\pard\sa80\sl276\slmult1\f1 class UserSerializer(serializers.ModelSerializer):\line     class Meta:\line         model = User\line         fields = ['id','username','email','first_name','last_name','user_type','bio','profile_picture','phone_number','location','qualification','experience_years','is_verified','date_joined','is_active']\line         read_only_fields = ['id','date_joined']\line \line class NotificationSerializer(serializers.ModelSerializer):\line     recipient = UserSerializer(read_only=True)\line     sender = UserSerializer(read_only=True)\line     class Meta:\line         model = Notification\line         fields = ['id','recipient','sender','notification_type','title','message','course','is_read','is_important','created_at']\line         read_only_fields = ['id','created_at']\f0\par
\pard\sa120\sl276\slmult1\b\i accounts/views.py (Dashboard excerpt)\b0\i0\par
\pard\sa80\sl276\slmult1\f1 @login_required\line def dashboard_view(request):\line     user = request.user\line     context = {'user': user, 'title': 'Dashboard'}\line     recent_status_updates = StatusUpdate.objects.filter(is_public=True).select_related('user')[:10]\line     context['recent_status_updates'] = recent_status_updates\line     if user.is_teacher:\line         from courses.models import Course, Enrollment\line         taught_courses = Course.objects.filter(teacher=user)\line         context['taught_courses'] = taught_courses[:5]\line         total_students = Enrollment.objects.filter(course__teacher=user, is_active=True).values('student').distinct().count()\line         context['total_students'] = total_students\line     elif user.is_student:\line         from courses.models import Enrollment, CourseCompletion\line         enrolled_courses = Enrollment.objects.filter(student=user, is_active=True)\line         context['enrolled_courses'] = [e.course for e in enrolled_courses[:5]]\line         completed_courses = CourseCompletion.objects.filter(student=user).count()\line         context['courses_completed_count'] = completed_courses\f0\par
}
